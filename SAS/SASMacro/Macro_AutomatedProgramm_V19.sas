*** check for subgroups: if item_description starts with if then go to next higher variable. Find the second word in the item_description by
	the scan-function which searches for entries after " ". Then compare this string with the format of the previous variable ("response_values_or_calculations").
	If the find function finds this expression in "response_values_or_calculations" adapt the condition statement of the macro execution and the sample size!.
	It would be also helpful to write a boolean in the csv, which indicates whether the variable is analysed per subject or per observation!.
	Listings (and tables) with label statement at the beginning.
*** create empty dataset if num_obs eq 0; ;

****************************************************************************************************************
Programme name:      Macro_AutomatedProgramme_V16
Initial date:        17MAR2015
Author:              Dennis Neuschwander
Shorthand symbol:    DN
Sponsor/study:       ARGOS-02
SAS-version:         9.4
****************************************************************************************************************
Short description:   Generates a documented programme for the generation of a table according to an csv-file 
					 with certain structure. The data of the csv-file are not only used to replace gaps in the 
					 template of the SAS-programme with values of certain variables but also to follow a decision
					 tree of if-statements. Depending on the decision tree the different parts of the 
					 SAS-programme are generated.
					 The macro repeats this action for every csv-file in the folder specified under the macro
					 parameter "inp_path".
					 Some adaptations of the automatically generated programme may be necessary before execution,
					 but usually no adaption should be necessary.
Risk assessment:     High
****************************************************************************************************************
Source of data:     
Input datasets:      csv.file (see Table_Demographics.csv in Z:\STATISTICS\12_SAS_Playground\DN for example
Output format:       .sas
Output type:         SAS-programme (usually, the programme can be directly executed without adaptations) 
Templates/macros:    
Required programmes: 
****************************************************************************************************************
Document history:    
Version     Date          Author     Purpose
01          17MAR2015     DN  	     First initiation
02			18MAR2015     DN		 Improvement of template
03			18MAR2015	  DN		 Improvement of template
04			19MAR2015	  DN 		 Adaption for more than one treatment
04			19MAR2015 	  DN 		 Adaption for two by-variables
05			25MAR2015	  DN		 Adaption for three by-variables
09			13MAY2015	  DN		 New style for tables added. Macro ready for tests.
10			18MAY2015     DN		 Macro parameter "inp_path", "input" and "out_path" added
11			19MAY2015	  DN		 Adaptions necessary due to errors detected in final tests 
12			20MAY2015  	  DN 		 Continuation of adaptions necessary due to errors detected in final tests 
13 			21MAY2015	  DN 		 There was some confusion about the style OBSDATASET (solved)
14			27MAY2015	  DN		 Final tests revealed necessity of adaptions for ATC style.
15			02JUN2015	  DN		 Macro parameter "input" deleted. Now the macro writes a SAS-Programme for 
									 each csv-file (template for table in the folder defined by macro parameter 
									 "inp-path". 
16			18JUN2015	  DN		 Automatic commentation improved and adaptions were necessary due to changes 
									 of the Excel template.
17 			19JUN2015	  DN		 Commentation of the programme and minor adaptations of the source code 
									 in order to increase comprehensibility of the programme and to avoid
									 numbers at the beginning of a dataset name.
18			05AUG2015	  DN		 Macro %SumStatistics referenced by this macro has an additional parameter 
									 and thus this macro had to be adapted.
19			06AUG2015	  DN		 If applicable, the version number is cut off of the analysed item and,
									 if specified in the excel-template for the table, the event-specific prefix
									 is cut off, too.

									 
*/

****************************************************************************************************************
*** Programme start
****************************************************************************************************************;
dm log 'clear'; 
*********************************************** Macro  Execution ***********************************************;
option spool;

*** The include-statements as well as the macro "IncludeProgrammes" is not necessary for the execution of the macro
	but of the execution of the SAS-programme generated by the macro "AutomatedProgramme";
*%include "Z:\STATISTICS\07_Templates\01_Analysis\04_Macros\Macro_IncludeProgrammes_V01.sas";
*%include "Z:\STATISTICS\07_Templates\01_Analysis\04_Macros\Macro_AssignFormats_V05.sas";
*%IncludeProgrammes(folder_path=Z:\STATISTICS\12_SAS_Playground\DN\Automated_Programme\Macros_to_include);

/* Line 66 to 86 - Generation of test data 
data ae_coding;
	set "Z:\STATISTICS\12_SAS_Playground\DN\AE_coding";
run;

proc sort data=m_q_01_screening_ungrouped;
	by subject_id;
run;
proc sort data=ae_coding;
	by subject_id;
run;
proc sort data=m_q_adverse_event_ungrouped;
	by subject_id;
run;
data m_q_adverse_event_ungrouped;
	merge m_q_adverse_event_ungrouped m_q_01_screening_ungrouped;
	by subject_id;
run;
data ae_screen;
	merge m_q_01_screening_ungrouped ae_coding (drop= __STUDYEVENTREPEATKEY);
	by subject_id;
run;
*/

****************************************************************************************************************
*** Macro Start
****************************************************************************************************************;
*** Macro parameter "inp_path". Path of the input folder with the csv-templates of the different tables;
*** Macro parameter "out_path". Output path of the output folder in which the generated SAS-programmes are saved;

*** New macro variable "csv_data&i". Name of th i-th csv-file in the input folder specified by "inp_path";
*** New macro variable "total". Total number of files in the input folder specified by "inp_path";

*** New variable "datasets_report". Variable with the name of all datasets that are part of the final dataset 
							  used for the table generation
*** New variable "condition". This variable is used to specify the macro parameter "condition" in the analysis 
							  macros and is used to count/analyse only observations that fulfill this condition.
*** New variable "previous_item". Item name of the item in the previous row of the SAS-dataset "programme_name"
*** New variable "prev_previous_item". Item name of the item in the row before the previous row of the SAS-dataset
							 "programme_name".
*** New variable "prev_previous_item". Item name of the item in the row before the previous row of the SAS-dataset
							 "programme_name".
*** New variable "previous_comment". Comment regarding the item in the previous row of the SAS-dataset
							 "programme_name".
*** New variable "prev_previous_comment". Comment of the item in the row before the previous row of the SAS-dataset
							 "programme_name".
*** New variable "sample size". String with the name of the macro variable that passes the number of observations 
							  for the calculation of the percentages to the analysis macro. In case of class-variables
							  the string is just "." as the analysis macros can not regard several sample sizes.
*** New variable "first_line_condition". If a condition is used in the first line, the whole table usually displays data of a subgroup, 
							  thus first_line_condition is used to check whether the subgroup changes within the table;
*** New variable "indicator_temp_subgroup". Indicates whether the analysis of at least one item but not all items only concerned a subgroup.
*** New variable "order". Order is used to remember the order of the items and commit the number of the current item to the analysis macro;

							  
%macro AutomatedProgramme (inp_path, out_path);

	*** create a SAS-dataset with nummeration and name of all csv-files saved in the input folder;
	*** create macro variables with the name of the csv-files and the the total number of csv-files;
	filename entry2 pipe "dir &inp_path /b";
	data m_dataset_list;
		infile entry2 truncover end=last;
		length csv_data $50.;
		retain i 0;
		input csv_data;
		i=i+1;
		call symput('csv_data'||trim(left(put(i,8.))),scan(trim(csv_data),1,'.'));
		if last then call symput('total',trim(left(put(i,8.))));
	run;
	
	%do table=1 %to &total;
	*** check whether values of "inp_path" and "out_put" end with "\" and add "\" if not (otherwise error occur);
		data _null_;
			length input $50.;
			if substr(strip("&inp_path"), length("&inp_path"), 1) ne "\" then do;
				inp_path="&inp_path" || "\";
				call symput("inp_path", strip(inp_path));
			end;
*			if upcase(substr(strip("&&csv_data&table"), length("&&csv_data&table")-3, 4)) ne ".CSV" then do;
*				input="&&csv_data&table" || ".csv";
*				call symput("&&csv_data&table", strip(input));
*			end;
			if substr(strip("&out_path"), length("&out_path"), 1) ne "\" then do;
				out_path="&out_path" || "\";
				call symput("out_path", strip(out_path));
			end;
		run; 

		*** delete the SAS-dataset "programme_data". This is necessary as the dataset is generated at each pass of the macro do-iteration;
		proc datasets library=work;
			delete programme_data;
		run;
		quit;

		*** import the &table-th csv-file containing the data for a SAS-programme that has to be generated;
		proc import datafile="&inp_path.&&csv_data&table...csv"
			replace 
			dbms=csv
			out=work.programme_data;
			guessingrows=10000;
			getnames=yes;
			delimiter=';';
		run;
	
		*** modify the SAS-dataset programme data by deleting the error message "#NV" and renaming the variables if necessary;
		*** since only a "_" is removed from the end of the variable name, the description of the variables remains as in the csv-file;
		data programme_data;
			set programme_data;
			option_value = tranwrd(option_value,'","', ',');
			if upcase(compress(comment_)) eq "#NV" then comment_="";
			if upcase(compress(description)) eq "#NV" then description="";
			if upcase(compress(percentages_)) eq "#NV" then percentages_="";  
			rename 	style_=style
					comment_=comment
					by_variable_1_=by_variable_1
					by_variable_2_=by_variable_2
					by_variable_3_=by_variable_3
					var_horizontal_=var_horizontal
					percentages_=percentages
					percentages_by_var_=percentages_by_var
					percentages_control_item_=percentages_control_item
					data_type_=data_type
					control_item_name_=control_item_name;
		run;
	
		data programme_data;
			set programme_data;
			first_ = find(item_name, "_");
			if(substr(item_name, length(strip(item_name))-2,1) eq "_"  and
			   substr(item_name, length(strip(item_name)),1) in ("0" "1" "2" "3" "4" "5" "6" "7" "8" "9") and
			   substr(item_name, length(strip(item_name))-1,1) in ("0" "1" "2" "3" "4" "5" "6" "7" "8" "9")) then do;
					vers_num_pos = find(item_name, "_", - (length(item_name)));
					item_name 	 = substr(item_name, 1, vers_num_pos-1);
			end;
			*if upcase(compress(event_prefix)) eq "YES" then substr(item_name, first_+1, length(item_name)-first_+1);
			if compress(control_item_name) ne "" then do;
				first_contr = find(control_item_name, "_");
				if (substr(control_item_name, length(strip(control_item_name))-2,1) eq "_"  and
				   substr(control_item_name, length(strip(control_item_name)),1) in ("0" "1" "2" "3" "4" "5" "6" "7" "8" "9") and
				   substr(control_item_name, length(strip(control_item_name))-1,1) in ("0" "1" "2" "3" "4" "5" "6" "7" "8" "9")) then do;
						vers_num_pos_contr = find(control_item_name, "_", -(length(control_item_name)));
						control_item_name  = substr(control_item_name, 1, vers_num_pos-1);
				end;
				*if upcase(compress(event_prefix)) eq "YES" then substr(control_item_name, first_contr+1, length(control_item_name)-first_contr+1);
			end;
		run;

		*** define macro variables that might be useful in the next step of the programme;
		*** The macro variables correspond to their equivalent in the csv-files.;
		data _null_;
			set programme_data;
			call symput ("programme_name", programme_name);
	*		if by_variable_1 ne "" then call symput ("by_variable_1", strip(by_variable_1));
	*		else call symput ("by_variable_1", "");
	*		if by_variable_2 ne "" then call symput ("by_variable_2", strip(by_variable_2));
	*		else call symput ("by_variable_2", "");
	*		if by_variable_3 ne "" then call symput ("by_variable_3", compress(by_variable_3));
	*		else call symput ("by_variable_3", "");
			call symput ("var_horizontal", strip(var_horizontal));
			if percentages ne "" then call symput ("percentages", strip(percentages));
			call symput ("percentages_by_var", strip(percentages_by_var));
			if strip(control_item_name) ne "" then call symput ("control_item_name", strip(control_item_name));
		run;

		*** the macro variable "init_day" contains the current day as value. This is used to document the initiation date of the SAS-Programme; 
		%let init_day=%sysfunc(today(),date9.);
		%put &init_day;
	
		*** Writting of the SAS-programme, that generates a table, by the use of the file-statement and the put-statement;
		*** The if-statements form decision trees that is used to assemble the different programme parts;
		data _null_;
			length datasets_report condition previous_item prev_previous_item previous_comment prev_previous_comment sample_size first_line_condition $32767.;
			retain datasets_report sample_size first_line_condition;		
			set programme_data end=eof;
			file  "&out_path.m_&programme_name._v01.sas" ;							*** specify output path and name of the programme;								
			retain indicator_temp_subgroup indicator_intended_entry 0;
			retain order 0;
			order = order + 1;
			previous_item 	      = compress(lag1(item_name));						*** the lagX-statement assigns the value of the indicated variable in the X-th row before the current row of the SAS-dataset;
			prev_previous_item    = compress(lag2(item_name));
			previous_comment      = compress(lag1(comment));
			prev_previous_comment =	compress(lag2(comment));
			prev_control_item 	  = strip(lag1(control_item_name));
		*** the following code is only executed in case of the first row of the SAS-dataset (e.g. writing the header of the SAS-programme, see line 235-265); 
			if _n_ eq 1 then do;
				put "/*";
				put 112*"*";
				put "Programme name:      m_&programme_name" "_v01";
				put "Initial date:        &init_day";
				put "Author:              " author;      
				put "Shorthand symbol:    " shorthand_symbol;
				put "Sponsor/study:       " study_name;
				put "SAS-version:         9.4";
				put 112*"*";
				put "Short description:   Table '" title_table +(-1)"'"; 
				put "Risk assessment:     Small";
				put 112*"*";
				put "Source of data:      Closed database of our DM";
				put "Input datasets:      " dataset;
				put "Output format:       RTF";
				put "Output type:         Table generated by proc report ";
				put "Templates/macros:    ";
				put "Required programmes: ";
				put 112*"*";
				put "Document history:    ";
				put "Version     Date        Author   Purpose";
				put "01	         &init_day   " shorthand_symbol +(-1)"      First initiation";
				put "*/";
				put ; 
				put 112*"*";
				put "*** Programme start";
				put 112*"*" ";";
				put;
				put 47*"*" " Macro  execution " 47*"*" ";";
				put '*** see variable "var_description" and "name_tab" respectively for description of analyzed variable;';
				put;	
	
				*** the code in the next lines until line 292 is used to decide by a decision tree which macro should be used to calculate the denominator for the calculation of
					the percentages	and to define the values of the corresponding macro parameters;
				if (upcase(strip(percentages_by_var)) eq "" or compress(by_variable_1) eq "") and compress(upcase(percentages_control_item)) eq "YES" and strip(control_item_name) ne "" then do;
					condition =strip(control_item_name) || " in (" || compress(option_value) || ")";
					put "*** Count the number of observations in the dataset the percentages are related to;";
					if compress(upcase(percentages_control_item)) eq "YES" and strip(control_item_name) ne "" and upcase(compress(percentages)) ne "ALL_OBS" then put "%" "CountObs(input=" dataset +(-1)"," / @11 "name=num_obs," / @11 "no_rep=" percentages +(-1) "," /@11 "condition=" condition +(-1) ");" /;
					else if strip(control_item_name) ne "" and  compress(upcase(percentages_control_item)) eq "YES" and upcase(compress(percentages)) eq "ALL_OBS" then put "%" "CountObs(input=" dataset +(-1)"," / @11 "name=num_obs," / @11 "no_rep=," /@11 "condition=" condition +(-1) ");" /;
					sample_size ='&m_num_obs';
				end;
				else if (upcase(strip(percentages_by_var)) eq "" or compress(by_variable_1) eq "") and (compress(upcase(percentages_control_item)) ne "YES" or strip(control_item_name) eq "") then do;
					put "*** Count the number of observations in the dataset the percentages are related to;";
					if upcase(compress(percentages)) ne "ALL_OBS"  then put "%" "CountObs(input=" dataset +(-1) "," / @11 "name=num_obs," / @11 "no_rep=" percentages +(-1) "," /@11 "condition=);" /;
					else if upcase(compress(percentages)) eq "ALL_OBS" then put "%" "CountObs(input=" dataset +(-1) "," / @11 "name=num_obs," / @11 "no_rep=," /@11 "condition=);" /;
					sample_size ='&m_num_obs';
				end;
				else if upcase(strip(percentages_by_var)) in ("BY_VARIABLE_1" "BY_VARIABLE_1 BY_VARIABLE_2" "BY_VARIABLE_1 BY_VARIABLE_2 BY_VARIABLE_3") then do;
					sample_size=.;
					put "*** Count the number of observations per class as the percentages are related to the class variable(s);";
					put "%" "SubjectsPerClass(input=" dataset +(-1) "," / @19 "class_variables=" &percentages_by_var  +(-1) "," ;
					if compress(upcase(percentages)) ne "ALL_OBS" then put @19 "no_rep=" percentages +(-1)",";
						else put  @19 "no_rep=,";
					if strip(upcase(percentages_control_item)) eq "YES" and strip(control_item_name) ne "" then put @19 "condition=" control_item_name " in (" option_value +(-1)"));"; 
						else if strip(upcase(percentages_control_item)) ne "YES" or strip(control_item_name) eq "" then put @19 "condition=);";
					put;
				end;
				if strip(control_item_name) ne "" then first_line_condition=strip(control_item_name) || " in (" || compress(option_value) || ")";
			end;

		*** the code in the next lines is not only executed in case of the first row of the SAS-dataset but also for all other rows;
			*** decision tree for the commentation of the generated SAS-programme (Minor terms and minor minor terms get no comment line);
			if find(upcase(strip(prev_previous_comment)),"MINOR_MINOR", 1) gt 0 and find(upcase(strip(previous_comment)),"MINOR", 1) gt 0
				then put 49*"*" " " item_name previous_item prev_previous_item 49*"*" ";";
			else if find(upcase(strip(previous_comment)),"MINOR", 1) gt 0 and find(upcase(strip(prev_previous_comment)),"MINOR_MINOR", 1) ne 0
				then put 49*"*" " " item_name previous_item 49*"*" ";";
			else if find(upcase(strip(comment)), "MINOR", 1) eq 0 then put 49*"*" " " item_name 49*"*" ";";

		*** the code in the next lines until line 337 is used to decide by a decision tree which macro should be used to calculate the denominator for the calculation of percentages
			***	this code is only executed if the denominator for the calculation of percentages differs from the denominator used for the analysis of the previous item;
			if _n_ > 1 and (upcase(strip(percentages_by_var)) eq "" or compress(by_variable_1) eq "") and (strip(control_item_name) eq "" or compress(upcase(percentages_control_item)) ne "YES") 
														and (strip(upcase(lag1(dataset))) ne strip(upcase(dataset)) or strip(upcase(lag1(percentages))) ne strip(upcase(percentages))) then do;
				put "*** Count the number of observations in the dataset the percentages are related to;";
				if upcase(compress(percentages)) ne "ALL_OBS" then put "%" "CountObs(input=" dataset +(-1) "," / @11 "name=num_obs," / @11 "no_rep=" percentages +(-1) "," /@11 "condition=);" /;
				else if upcase(compress(percentages)) eq "ALL_OBS" then put "%" "CountObs(input=" dataset +(-1) "," / @11 "name=num_obs," / @11 "no_rep=," /@11 "condition=);" /;
				sample_size ='&m_num_obs';
			end;
			else if _n_ > 1 and (upcase(strip(percentages_by_var)) eq "" or compress(by_variable_1) eq "") and (strip(control_item_name) ne "" and compress(upcase(percentages_control_item)) eq "YES") 
														and (strip(upcase(lag1(dataset))) ne strip(upcase(dataset)) or strip(upcase(lag1(percentages))) ne strip(upcase(percentages))
														or   strip(upcase(control_item_name))ne strip(upcase(prev_control_item))) then do;
														condition =strip(control_item_name) || " in (" || compress(option_value) || ")";
				put "*** Count the number of observations in the dataset the percentages are related to;";
				if compress(percentages_by_var) eq "" and upcase(compress(percentages)) ne "ALL_OBS" then put "%" "CountObs(input=" dataset +(-1)"," / @11 "name=num_obs_subgroup," / @11 "no_rep=" percentages +(-1) "," /@11 "condition=" condition +(-1) ");" /;
				else if compress(percentages_by_var) eq "" and upcase(compress(percentages)) eq "ALL_OBS" then put "%" "CountObs(input=" dataset +(-1)"," / @11 "name=num_obs_subgroup," / @11 "no_rep=," /@11 "condition=" condition +(-1) ");" /;
				indicator_temp_subgroup = 1;
				sample_size ='&m_num_obs_subgroup';
			end;
			else if _n_ > 1 and upcase(strip(percentages_by_var)) in ("BY_VARIABLE_1" "BY_VARIABLE_1 BY_VARIABLE_2" "BY_VARIABLE_1 BY_VARIABLE_2 BY_VARIABLE_3") and 
																	 (strip(upcase(lag1(percentages_by_var))) ne strip(upcase(percentages_by_var))
																	 or strip(upcase(lag1(percentages))) ne strip(upcase(percentages))
																	 or strip(upcase(lag1(dataset))) ne strip(upcase(dataset))
																	 or strip(upcase(lag1(percentages_control_item))) ne strip(upcase(percentages_control_item))
																	 or (compress(upcase(percentages_control_item)) eq "YES" and strip(upcase(lag1(control_item_name))) ne strip(upcase(control_item_name)))) 
																	 then do;
				%let num_obs=.;
				put "*** Count the number of observations per class as the percentages are related to the class variable(s);";
				put "%" "SubjectsPerClass(input=" dataset +(-1) "," / @19 "class_variables=" &percentages_by_var  +(-1) "," ;
					if compress(upcase(percentages)) ne "ALL_OBS" then put @19 "no_rep=" percentages +(-1)",";
						else put  @19 "no_rep=,";
					if strip(upcase(percentages_control_item)) eq "YES" and control_item_name ne "" then put @19 "condition=" control_item_name " in (" option_value +(-1)"));"; 
						else if strip(upcase(percentages_control_item)) ne "YES" or strip(control_item_name) eq "" then put @19 "condition=);";
				put;
			end; 
			
			*** execute some adaptations for some parameters in case of analysis of a subgroup;
			if upcase(substr(item_name, 1, 2)) eq "M_" then item_name = substr(item_name, 3, length(item_name)-2); 	* removal of "M_", if the item_name start with these two characters;
			condition = "";
			if strip(control_item_name) ne "" then do;																* define variable condition if necessary;
				condition =strip(control_item_name) || " in (" || compress(option_value) || ")";
				if compress(first_line_condition) ne "" and compress(upcase(first_line_condition)) ne compress(upcase(condition)) 
				and compress(upcase(percentages_control_item)) eq "YES" then do;
					indicator_temp_subgroup = 1;																	* adapt the value of the variable indicator_temp_subgroup if necessary;
					item_description = item_description || "*";														* adapt the value of the variable item_description if necessary;	
				end;
			end;
	
		*** the code in the next lines until line 363 adds a proc sort to the SAS-programme taht is currently written if necessary;
			if by_variable_1 ne "" and _n_ eq 1 then do;
				put "proc sort data=" dataset";";
				put "	by " by_variable_1 by_variable_2 by_variable_3 +(-1) ";";
				put "run;"; 
				put;
			end;
			else if by_variable_1 ne "" and _n_ ne 1 and dataset ne lag1(dataset) then do;
				put "proc sort data=" dataset";";
				put "	by " by_variable_1 +(-1) by_variable_2 by_variable_3 +(-1)";";
				put "run;";
				put;
			end;

		*** the code in the next lines until line 539 is used to decide based on a decision tree which macro(s) should be used to analyse the current item and to define the values
			of the corresponding macro parameters;
			*** depending on the style chosen it might be necessary to modify the input dataset prior to and/or during the analysis of the item --> This is also decided in the next lines;
			if upcase(compress(comment)) not in ("MINOR_TERM" "MINOR_MINOR_TERM") then put "*** Analysis of the item;"; 
			if compress(item_units) ne "" and compress(upcase(item_units)) ne "YYYY" and find(upcase(data_type), "DATE", 1) ne 0 then item_description = trim(item_description) || " [" || trim(item_units) || "]"; *add the unit of a measurement to the item description if applicable;
			if compress(upcase(data_type)) eq "FLOATING" then do;
				put "%" "SumStatistics(var=" item_name +(-1) "," / @16 "suborder=" order +(-1)"," / @16 "name_tab='" item_description +(-1)"'," / @16 "input=" dataset +(-1)"," 
					/ @16 "output=" item_name +(-1) "," / @16 "condition=" condition +(-1) "," / @16 'num_subj=' sample_size +(-1) "," / @16 "column_name=total,"
					/ @16 "class_variables=" by_variable_1 by_variable_2 by_variable_3 +(-1) "," / @16 "level=1);";
				datasets_report = strip(datasets_report) || " m_" || strip(item_name);
				put;
			end;
			else if compress(upcase(data_type)) eq "INTEGER" and find(upcase(data_type), "DATE", 1) eq 0 and compress(upcase(item_units)) ne "YYYY" and  strip(control_item_name) eq "" then do;
				format_name = compress(item_name) ||"_F.";
				put "%" "Frequency(var=" item_name +(-1)"," / @16 "suborder=" order +(-1)"," / @16 "name_tab='" item_description +(-1)"'," / @16 "input=" dataset +(-1) "," 
					/ @16 "output=" item_name +(-1)"," / @16 "format=" format_name +(-1)"," / @16 "condition=" condition +(-1) "," / @16 'num_subj=' sample_size +(-1) ','
					/ @16 "class_variables=" by_variable_1 by_variable_2 by_variable_3 "," / @16 "column_name=total," / @16 "level=1);";
				datasets_report = strip(datasets_report) || " m_" || strip(item_name);
				put;
			end;
			else if compress(upcase(data_type)) eq "INTEGER" and find(upcase(data_type), "DATE", 1) eq 0 and strip(control_item_name) ne "" then do;
				format_name = compress(item_name) ||"_F.";
				put "%" "Frequency(var=" item_name +(-1)"," / @16 "suborder=" order +(-1)"," / @16 "name_tab='" item_description +(-1)"*'," / @16 "input=" dataset +(-1)"," 
					/ @16 "output=" item_name +(-1)"," / @16 "format=" format_name +(-1)"," / @16 "condition=" condition +(-1)"," / @16 'num_subj=' sample_size +(-1) ','
				    / @16 "column_name=total," / @16 "class_variables=" by_variable_1 %if by_variable_2 ne %then by_variable_2; %if by_variable_3 ne %then by_variable_3; +(-1)","
					/ @16 "level=2);";
				indicator_intended_entry=1;
				datasets_report = strip(datasets_report) || " m_" || strip(item_name);
				put;
			end;
			else if upcase(strip(style)) eq "OBSDATASET" and compress(by_variable_1) eq "" then do; 
*				order = order - 0.01;
				if compress(by_variable_1) eq  "" then do; 
					condition =strip(control_item_name) || " in (" || compress(option_value) || ")";
*					set_nr = compress(order + 0.01);
					put "%" "ObsDataset (input=" dataset +(-1) "," / @13 "no_rep=" percentages +(-1) ",";
					put @13 "output=m_" item_name +(-1) order +(-1) ",";
					put @13 "order=" order "," / @13 "var_description='" description +(-1)"',"; 
					if strip(control_item_name) ne "" then put @13 "condition=" condition +(-1)",";
					else if strip(control_item_name) eq "" then 	put "condition=,";
					put @13 "num_subj=" sample_size "," / @13 "column_name=total);";
*					order = order + 0.01;
					
				end;
			end;
			else if upcase(strip(style)) eq "OBSDATASET" and compress(by_variable_1) ne "" then do; 
*				order = order - 0.01;
				put "data no_dups;" / @5 "set " dataset +(-1) ";";													
				if strip(control_item_name) ne "" then put @5 "if " control_item_name "in (" option_value +(-1) ");";
				put	@5 "help_variable='" description +(-1) "';" / "run;" /; 
				if compress(percentages) ne "" and compress(percentages) ne  "ALL_OBS" then 
					put "proc sort data=no_dups nodupkey;" / @5 "by " percentages +(-1) ";" / "run;" /;  
				condition =strip(control_item_name) || " in (" || compress(option_value) || ")";
*				set_nr = compress(order + 0.01);
				put "%" "FreqMedCodeAuto(input=no_dups,";
				put @18 "output=m_" item_name +(-1) order +(-1) "," / @18 "umbrella_term=help_variable,";
				put @18 "minor_term=," / @18 "minor_minor_term=,";
				if compress(percentages) eq "" then put @18 "no_rep_start=" "," / @18 "no_rep_end=,";
				else if compress(percentages) ne "" then put @18 "no_rep_start=by " percentages +(-1) "," / @18 "no_rep_end=,";
				put @18 'num_subj=' sample_size +(-1) ',';
				put @18 "column_name=total," / @18 "condition=," / @18 "class_variables=" by_variable_1 by_variable_2 by_variable_3 +(-1) ");";
				datasets_report = strip(datasets_report) || " m_" || strip(item_name) || strip(put(order,2.));
				put;
			end;
			else if upcase(strip(style)) eq "ATC" and compress(by_variable_1) eq "" and upcase(strip(comment)) not in ("MINOR_TERM" "MINOR_MINOR_TERM") then do;
				if compress(upcase(previous_comment)) eq "MINOR_TERM" and compress(upcase(prev_previous_comment)) eq "MINOR_MINOR_TERM" then order = order - 2.01;
				else if compress(upcase(previous_comment)) eq "MINOR_TERM" then order = order - 1.01;
				else order = order - 0.01;
				condition =strip(control_item_name) || " in (" || compress(option_value) || ")";
				if compress(by_variable_1) eq  "" then do; 
					put "%" "ObsDataset (input=" dataset +(-1) "," / @13 "no_rep=" %if &var_horizontal ne "" %then var_horizontal +(-1); ",";
					if upcase(strip(style)) eq "ATC" then put @13 "output=m_" item_name +(-1) "_0,";
					put @13 "order=" order "," / @13 "var_description='" description "',"; 
					if strip(control_item_name) ne "" then put @13 "condition=" condition +(-1) ",";
					else if strip(control_item_name) eq "" then 	put @13 "condition=,";
					put @13 "num_subj=" sample_size "," / @13 "column_name=total);";
					order = order + 0.01;
					datasets_report = strip(datasets_report) || " m_" || strip(item_name) || "_0";
				end;
			end;

			if upcase(strip(style)) eq "ATC" and compress(by_variable_1) ne "" and upcase(compress(comment)) not in  ("MINOR_TERM" "MINOR_MINOR_TERM") then do;
				put "data no_dups;" / @5 "set " dataset +(-1) ";";
				if strip(control_item_name) ne "" then put @5 "if " control_item_name "in (" option_value +(-1)");";
				put @5 "help_variable='" description +(-1) "';" / "run;" /; 
				put "%" "FreqMedCodeAuto(input=no_dups,";
				put @18 "output=m_" item_name +(-1) "_0," / @18 "umbrella_term=help_variable,";
				put @18 "minor_term=," / @18 "minor_minor_term=,";
				if compress(percentages) eq "" or compress(upcase(percentages)) eq "ALL_OBS" then put @18 "no_rep_start=," / @18 "no_rep_end=,";
				else if compress(percentages) ne "" then put @18 "no_rep_start=by " percentages +(-1) "," / @18 "no_rep_end=,";
				put @18 'num_subj=' sample_size +(-1) ',';
				put @18 "column_name=total," / @18 "condition=," / @18 "class_variables=" by_variable_1 by_variable_2 by_variable_3 +(-1) ");";
				if upcase(strip(style)) eq "ATC" then datasets_report = strip(datasets_report) || " m_" || strip(item_name) || "_0";
				put;
			end;

		    if upcase(strip(style)) in ("AE" "SOC_PT" "ATC") and compress(by_variable_1) ne "" and compress(upcase(comment)) not in  ("MINOR_TERM" "MINOR_MINOR_TERM") then do;
				put "%" "FreqMedCodeAuto(input=" dataset +(-1) ","; 
				if upcase(strip(style)) eq ("SOC_PT") then put @18 "output=m_" item_name +(-1)",";
				else if upcase(strip(style)) in ("AE" "ATC") then put @18 "output=m_" item_name +(-1) "_1,";
				put @18 "umbrella_term=" item_name +(-1)  ",";
				if 		upcase(previous_comment) eq "MINOR_TERM" and upcase(prev_previous_comment) eq "MINOR_MINOR_TERM" 
					then put @18 "minor_term=" previous_item +(-1)"," /@18 "minor_minor_term=" prev_previous_item +(-1) ",";
				else if upcase(previous_comment) eq "MINOR_TERM" and upcase(prev_previous_comment) ne "MINOR_MINOR_TERM" 
					then put @18 "minor_term=" previous_item +(-1)"," /@18 "minor_minor_term=,";
				else if upcase(previous_comment) ne "MINOR_TERM" then put @18 "minor_term=," / @18 "minor_minor_term=,";
				if compress(percentages) eq "" or compress(upcase(percentages)) eq "ALL_OBS" then put @18 "no_rep_start=," / @18 "no_rep_end=,";
				else if compress(percentages) ne "" then put @18 "no_rep_start=by " percentages +(-1) "," / @18 "no_rep_end=,";
				put @18 'num_subj=' sample_size +(-1) ',';
				put @18 "column_name=total" "," / @18 "condition=" condition +(-1) "," / @18 "class_variables=" by_variable_1 by_variable_2 by_variable_3 +(-1) ");";
				put;
				if upcase(strip(style)) eq ("AE") then do;
					put "%" "FreqMedCodeAuto(input=" dataset +(-1) "," / @18 "output=m_" item_name +(-1) "_2," / @18 "umbrella_term=" item_name +(-1)  ",";
					if 		upcase(previous_comment) eq "MINOR_TERM" and upcase(prev_previous_comment) eq "MINOR_MINOR_TERM" 
						then put @18 "minor_term=" previous_item +(-1)"," /@18 "minor_minor_term=" prev_previous_item +(-1) ",";
					else if upcase(previous_comment) eq "MINOR_TERM" and upcase(prev_previous_comment) ne "MINOR_MINOR_TERM" 
						then put @18 "minor_term=" previous_item +(-1)"," /@18 "minor_minor_term=,";
					else if upcase(previous_comment) ne "MINOR_TERM" then put @18 "minor_term=," / @18 "minor_minor_term=,";
					put @18 "no_rep_start=," / @18 "no_rep_end=,";
					put @18 'num_subj=' sample_size +(-1) ',';
					put @18 "column_name=total" "," / @18 "condition=" condition +(-1) "," / @18 
						"class_variables=" by_variable_1 by_variable_2 by_variable_3 +(-1) ");";
					put;
				end;
				if upcase(strip(style)) eq "AE" and find(upcase(strip(percentages_by_var)), "BY_VARIABLE_1", 1) gt 0 then do;
					put "*** Recalculate the percentages. Necessary since the macro parameter 'num_subj' is equal to '.'" /
							@5 "and the percentages are to be calculated separately for the class-variables;";
					put "%" "RecalcPercentages(input=m_" item_name +(-1) "_1," / 
							  @21 "freq_data=Frequencies," / @21 "class_variables=" &percentages_by_var +(-1)"," / @21 "output=" item_name +(-1)"_1);" / ;
							  datasets_report = strip(datasets_report) || " m_" || strip(item_name);
				end;
				if upcase(style) eq "AE" then do;
					put "*** Merge the datasets generated above in order to combine their entries. The combined entries have the typical AE style 'n  (xxx.x)  m';";
					put "proc sort data=m_" item_name +(-1) "_1;";
					put @5 "by " by_variable_1 by_variable_2 by_variable_3 "var_description;";
					put "run;"; 
					put;
					put "proc sort data=m_" item_name +(-1) "_2;";
					put @5 "by " by_variable_1 by_variable_2 by_variable_3 "var_description;";
					put "run;"; 
					put;
					put "data m_" item_name +(-1) ";";
					put @5 "length total $18.;";
					put @5 "merge m_" item_name +(-1) "_1 (rename=(total=total_old)) "  / @11 "m_" item_name +(-1) "_2 (rename=(count=count_new) drop=total);";
					put @5 "by " by_variable_1 by_variable_2 by_variable_3 "var_description;";
					put @5 "if count_new eq . then count_new = 0;";
					put @5 "total=total_old || '" "' || put(count_new, 4.);";
					put @5 "drop total_old;";
					put "run;";
					put;
				end;
				if upcase(style) eq "ATC" then do;
					if by_variable_1 ne "" then do;
						put "proc sort data=m_" item_name +(-1) "_0;" / @5 "by " by_variable_1 by_variable_2 by_variable_3 +(-1)";" / "run;";
						put;
						put "proc sort data=m_" item_name +(-1) "_1;" / @5 "by " by_variable_1 by_variable_2 by_variable_3 +(-1)";" / "run;" /;
						put "data m_" item_name +(-1) "_0;" / @5 "merge m_" item_name +(-1) "_0 (drop=order suborder)" / @11 "m_" item_name +(-1) "_1 (drop=var_description total count);"
							/ @5 "by " by_variable_1 by_variable_2 by_variable_3 ";" / @5 "order = order - 0.001;" / "run;";
						put;
						put "proc sort data=m_" item_name +(-1) "_0 nodupkey;" / @5 "by " by_variable_1 by_variable_2 by_variable_3 +(-1)";" / "run;" /;
					end;
					put "data m_" item_name +(-1) ";" / @5 "set m_" item_name +(-1) "_0" / @9 "m_" item_name +(-1) "_1;" / "run;" /;  	
				end;
			end;
			else if find(upcase(comment), "UMBRELLA", 1) gt 0 or (compress(upcase(data_type)) eq "CHARACTERSTRING" and comment eq "") and strip(upcase(style)) ne "OBSDATASET" then do;
				put "%" "FreqMedCodeAuto(input=" dataset +(-1) "," / @18 "output=m_" item_name +(-1) "," / @18 "umbrella_term=" item_name +(-1)  ",";
				if 		upcase(previous_comment) eq "MINOR_TERM" and upcase(prev_previous_comment) eq "MINOR_MINOR_TERM" 
					then put @18 "minor_term=" previous_item +(-1)"," /@18 "minor_minor_term=" prev_previous_item +(-1) ",";
				else if upcase(previous_comment) eq "MINOR_TERM" and upcase(prev_previous_comment) ne "MINOR_MINOR_TERM" 
					then put @18 "minor_term=" previous_item +(-1)"," /@18 "minor_minor_term=,";
				else if upcase(previous_comment) ne "MINOR_TERM" then put "minor_term=," / @18 "minor_minor_term=,";
				put @18 "no_rep_start=" "," / @18 "no_rep_end=" "," / @18 "num_subj=" sample_size +(-1) "," / @18 "column_name=total" "," / @18 "condition=" condition +(-1) "," 
				  / @18 "class_variables=" by_variable_1 by_variable_2 by_variable_3 +(-1) ");";
				put;
				datasets_report = strip(datasets_report) || " m_" || strip(item_name);
			end;

		*** the code in the next lines until line 592 is used to decide based on a decision tree if it is necessary to recalculate the percentages in the dataset with the results of the analysis of the item
		    and whether presentation of the results should be adapted (e.g. if the results per class should be displayed with a separate column for each characteristic of the first class-variable in the table;
			if compress(by_variable_1) ne "" and compress(comment) eq "" and upcase(strip(style)) not in ("AE" "ATC" "SOC_PT" "OBSDATASET") then do;
				if compress(percentages_by_var) ne "" then do;
					put "*** Recalculate the percentages. Necessary since the macro parameter 'num_subj' is equal to '.'" / 
							 @5 "and the percentages are to be calculated separately for the class-variables;";
					put "%" "RecalcPercentages(input=m_" item_name +(-1) ",";	
					put @21 "freq_data=Frequencies," / @21 "class_variables=" &percentages_by_var +(-1)"," / @21	"output=" item_name +(-1)");";
				end;
				put;
				if var_horizontal ne "" then do;
					put "*** Reformat the frequencies so that the results for each characteristic of the first class variables are displayed in their own column in the final table;";
					put "%" "ReformatFrequencies(input=m_" item_name +(-1) "," / @21 "output=" item_name +(-1) "," / @21 "var_horizontal=" by_variable_1 +(-1) "," / @21
						"var_vertical_1=var_description," / @21 "var_vertical_2=" by_variable_2 +(-1) "," / @21 
						"var_vertical_3="  by_variable_3 +(-1) "," / @21   "column_name=total);";
					put;
				end;
				put;
			end;
			else if compress(by_variable_1) ne "" and compress(comment) eq "" and upcase(strip(style)) eq ("OBSDATASET") then do;
				if compress(percentages_by_var) ne "" then do;
					put "*** Recalculate the percentages. Necessary since the macro parameter 'num_subj' is equal to '.'" /
							 @5 "and the percentages are to be calculated separately for the class-variables;";
					put "%" "RecalcPercentages(input=m_" item_name +(-1) order +(-1)",";	
					put @21 "freq_data=Frequencies," / @21 "class_variables=" &percentages_by_var +(-1)"," / @21	"output=" item_name +(-1) order +(-1)");";
				put;
				end;
				if var_horizontal ne "" then do;
					put "*** Reformat the frequencies so that the results for each characteristic of the first class variables are displayed in their own column in the final table;";
					put "%" "ReformatFreqMedCode(input=m_" item_name +(-1) order +(-1) "," / @21 "output=" item_name +(-1) order +(-1) "," / @21 "umbrella_term=help_variable," / @21
						"var_horizontal=" by_variable_1 +(-1) "," / @21 "var_vertical_1=var_description," / @21 "var_vertical_2=" by_variable_2 +(-1) "," / @21 
						"var_vertical_3="  by_variable_3 +(-1) "," / @21   "column_name=total);";
					put;
				end;
				put;
			end;
			else if compress(by_variable_1) ne "" and compress(upcase(comment)) not in  ("MINOR_TERM" "MINOR_MINOR_TERM")  then do;
				if compress(percentages_by_var) ne "" and upcase(strip(style)) ne "AE" then do;
					put "*** Recalculate the percentages. Necessary since the macro parameter 'num_subj' is equal to '.'" /
							 @5 "and the percentages are to be calculated separately for the class-variables;";
					put "%" "RecalcPercentages(input=m_" item_name +(-1) "," / @21 "freq_data=Frequencies," / @21 "class_variables=" &percentages_by_var +(-1)"," / @21
					"output=" item_name +(-1)");" / ;
				end;
				if var_horizontal ne "" then do;
					put "*** Reformat the frequencies so that the results for each characteristic of the first class variables are displayed in their own column in the final table;";
					put "%" "ReformatFreqMedCode(input=m_" item_name +(-1) "," / @21 "output=" item_name +(-1) "," / @21 "umbrella_term=" item_name +(-1) "," / @21
						"var_horizontal=" by_variable_1 +(-1) "," / @21 "var_vertical_1=var_description," / @21 "var_vertical_2=" by_variable_2 +(-1) "," / @21 
						"var_vertical_3="  by_variable_3 +(-1) "," / @21   "column_name=total);";
					put;
				end;
				put;
			end;

		*** the code in the remaining lines is only executed if the end of the SAS-dataset "programme_data" is reached;
			*** the datasets with the analysis results of the different items are assembled in a single dataset, the dataset is ordered and the proc report is written;
			if eof then do;
				put ;
				put 39*"*" " Prepare dataset for proc report " 40*"*" ";";
				put '*** New variable "dummy". Help variable to suppress third node of table of contents;';
				put "data data_&programme_name;"; 
				if upcase(strip(style)) not in  ("AE" "SOC_PT" "ATC") then put @5 "set " datasets_report ";";
				else if upcase(strip(style)) in ("AE" "SOC_PT" "ATC") then put @5 "set m_" item_name +(-1) ";";
				put @5 "*if compress(upcase(var_description)) ne 'OVERALL';";
				if compress(by_variable_1) ne "" and var_horizontal eq "" then put  @5 "if compress(" by_variable_1 +(-1) ") eq '.' then " by_variable_1 " = '';"
																				  / @5 "*if compress(upcase(" by_variable_1 +(-1)")) ne 'OVERALL';";
				if compress(by_variable_2) ne "" then put  @5 "if compress(" by_variable_2 +(-1) ") eq '.' then " by_variable_2 " = '';"
														 / @5 "*if compress(upcase(" by_variable_2 +(-1)")) ne 'OVERALL';";
				if compress(by_variable_3) ne "" then put  @5 "if compress(" by_variable_3 +(-1) ") eq '.' then " by_variable_3 " = '';";
				put @5 "dummy = 1;";
				put "run;";
				put ;
				put "proc sort data=data_&programme_name;";
				put "	by order suborder;";
				put "run;" /;
				if indicator_intended_entry eq 1 then do;
					put "*** If an intended entry in the 'var_description' is longer than the column width, the following macro intends the entry after a line break;"; 
					put "%" "SplitInsertCharAuto(input=data_&programme_name," / @ 21 "output=data_&programme_name," / @21 "var=var_description," / @21 "width=31.27," / @21 "delimiter='^n');" /;
					put "data data_&programme_name;" / @5 "set data_&programme_name;" / @5 "rename m_var_description=var_description;" / "run;" /; 
				end;
				if var_horizontal ne "" then put "%" 'put &all_format_char;' /;
				put "ods rtf file='Z:\STATISTICS\12_SAS_Playground\DN\Argos-02_Interim_analysis_draft01.rtf'";
				put "startpage=Yes";
				put "style=DedeStyle";
				put "contents";
				put "bodytitle";
				put "toc_data;";
				put 'ods escapechar="^";';
				put;
				put '%' 'let' ' counti=%eval(&counti+1);';
				put 'ods proclabel="Table &counti: ' title_table +(-1) '";';
				put 'title1 bold j=l height=10pt font=curier "^R'"''" 'Table &counti:' title_table +(-1) '";';
				put 39*"*"  " Table generation by proc report "  40*"*" ";";
				put "proc report data=data_&programme_name headline headskip nowd split='|' missing contents='';";

				*** the following if-statement determines the number and name of the columns of the table depending on the appearance of the table;
				if compress(by_variable_1) eq "" then put "	  columns (dummy order var_description total);";	
				else if compress(var_horizontal) eq "" then put'   columns (dummy  ' by_variable_1 by_variable_2 by_variable_3 ' order var_description total);';
				else if compress(var_horizontal) ne "" then put'	 columns (dummy ' by_variable_2 by_variable_3 ' order var_description &all_format_char);';
				put "	define dummy / order noprint;"; 
				put "	define order / order order=data noprint;";

				***the following three if-statements determine how the columns are processed depending on the number of class-variables (by-variables) and the appearance of the table;
				if compress(by_variable_1) ne "" and var_horizontal eq "" then put  "	define " by_variable_1  "/ order order=data flow style(column)=[cellwidth=2.5 cm];";
				if compress(by_variable_2) ne "" then put  "   define " by_variable_2  "/ order order=data group flow style(column)=[cellwidth=2.5 cm];";
				if compress(by_variable_3) ne "" then put  "   define " by_variable_3  "/ order order=data group flow style(column)=[cellwidth=2.5 cm];";
				put "	define var_description / ' ' flow style(column)=[cellwidth=6 cm];";
				if var_horizontal eq "" then put '   define total  / " Frequency  |  (N = &m_num_obs)   |  n   (%)" flow style(column)=[cellwidth=4 cm] left;';
				if upcase(strip(style)) ne "OBSDATASET" and compress(by_variable_1) ne "" or compress(upcase(style)) in ("ATC" "" "SOC_PT" "AE") then do;
					put "	compute before order;";
					put "		line ' ';";
					put "	endcomp;";
				end;
				put "	compute after;";
				put "		line ' ';";
				put "	endcomp;";
				put '	break before dummy / contents="" page;';
				put '	footnote1 font=curier height=9pt';
				put '	j=l "N: Number of subjects"';
				put '   j=l "n: Number of subjects with data available"';
				if indicator_temp_subgroup eq 1 then put '   j=l "*: Percentage based on subjects that fulfill the if-condition"';
				put '	j=l "%: Percentage based on N";';
				put "run;"; 
				put;
				put "ods rtf close;";
				put "ods _all_ close;";
			end;
		run;
	%end;
%mend AutomatedProgramme;

****************************************************************************************************************
*** Macro Call
****************************************************************************************************************;
* %AutomatedProgramme(inp_path=,
					out_path=);

